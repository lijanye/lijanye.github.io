(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{392:function(e,o,v){"use strict";v.r(o);var n=v(42),t=Object(n.a)({},(function(){var e=this,o=e.$createElement,v=e._self._c||o;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面"}},[e._v("#")]),e._v(" 面")]),e._v(" "),v("p",[e._v("5个问题\n1、css 尽可能多的说出你能想到的所有的无宽高的块级元素水平垂直居中的方法")]),e._v(" "),v("p",[e._v('2、如何判断一个数据类型是对象\nObject.propertype.toString().call(obj) === "[object,object]"')]),e._v(" "),v("p",[e._v("3、说说你对"),v("code",[e._v("AMD")]),e._v("和"),v("code",[e._v("CommonJS")]),e._v("的了解\n它们都是实现模块体系的方式，直到"),v("code",[e._v("ES2015")]),e._v("出现之前，"),v("code",[e._v("JavaScript")]),e._v(" 一直没有模块体系。\n"),v("code",[e._v("CommonJS")]),e._v(" 是同步的，而 "),v("code",[e._v("AMD（Asynchronous Module Definition）")]),e._v("从全称中可以明显看出是异步的。\n"),v("code",[e._v("CommonJS")]),e._v(" 的设计是为服务器端开发考虑的，而"),v("code",[e._v("AMD")]),e._v("支持异步加载模块，更适合浏览器。")]),e._v(" "),v("p",[e._v("我发现"),v("code",[e._v("AMD")]),e._v("的语法非常冗长，"),v("code",[e._v("CommonJS")]),e._v("更接近其他语言"),v("code",[e._v("import")]),e._v(" 声明语句的用法习惯。\n大多数情况下，我认为"),v("code",[e._v("AMD")]),e._v("没有使用的必要，因为如果把所有 "),v("code",[e._v("JavaScript")]),e._v(" 都捆绑进一个文件中，\n将无法得到异步加载的好处。\n此外，"),v("code",[e._v("CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript")]),e._v("开发之间进行切换时，\n语境的切换开销较小。")]),e._v(" "),v("p",[e._v("我很高兴看到"),v("code",[e._v("ES2015")]),e._v(" 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。\n虽然它尚未在浏览器和"),v("code",[e._v("Node")]),e._v("中完全推出，但是我们可以使用代码转换工具进行转换。")]),e._v(" "),v("p",[e._v("4、浏览器从输入一个网址到页面加载出来经历了哪些过程\n5、说说vue的生命周期顺序何执行顺序\n6、vue兄弟组件之间的传值几种方式\n6、vue 的设计模式和 双向绑定")]),e._v(" "),v("p",[e._v("杨振宇：\n1、css 尽可能多的说出你能想到的所有的无宽高的块级元素水平垂直居中的方法\n2、数组的常用方法有哪些 slice splice splice能够用来做哪些事情\n3、git reset 和git revert\n4、for in 和for of\n5、DOCTYPE是“document type”的缩写。它是 HTML 中用来区分标准模式和怪异模式的声明，用来告知浏览器使用标准模式渲染页面。\n从中获得的启发：在页面开始处添加"),v("code",[e._v("<!DOCTYPE html>")]),e._v("即可。\n6、浏览器从输入url到页面完全加载出来 整个过程")]),e._v(" "),v("p",[e._v("李平\n1、vue的生命周期  以及每个周期内做了哪些事情\n2、px rem em之间的换算关系\n3、bfc\n4、vue 组件 prop methonds data computed watch\nprops - > methods - > data - > computed - > watch\n父组件向子组件通过props传值，props是一个只读属性，如果要改变props的值，需要在data中进行定义，所以props在前，data在后\ncomputed计算属性要使用data里面的数据，所以data在前，computed在后\n5、跨域的一般几种方式\n6、你使用什么语句遍历对象的属性和数组的元素？\n7、vue的双向绑定 是如何实现的")])])}),[],!1,null,null,null);o.default=t.exports}}]);