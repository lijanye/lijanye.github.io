(window.webpackJsonp=window.webpackJsonp||[]).push([[267],{612:function(h,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var h=this,t=h.$createElement,a=h._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":h.$parent.slotKey}},[a("h3",{attrs:{id:"文件指纹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件指纹"}},[h._v("#")]),h._v(" 文件指纹")]),h._v(" "),a("p",[h._v("静态资源缓存是前端优化的几种方式之一， 如果文件名保持不变的话，在命中强缓存的时候会导致文件不是最新的，所以我们需要使用hash值来保证我们每次用到的都是最新的文件")]),h._v(" "),a("h3",{attrs:{id:"hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[h._v("#")]),h._v(" hash")]),h._v(" "),a("p",[h._v("如果都使用hash的话，因为这是工程级别的，即每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效")]),h._v(" "),a("h3",{attrs:{id:"chunkhash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chunkhash"}},[h._v("#")]),h._v(" chunkhash")]),h._v(" "),a("p",[h._v("chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。并且webpack4中支持了异步import功能，固，chunkhash也作用于此。")]),h._v(" "),a("h3",{attrs:{id:"contenthash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contenthash"}},[h._v("#")]),h._v(" contenthash")]),h._v(" "),a("p",[h._v("contenthash是针对文件内容级别的，只有你自己模块的内容变了，那么hash值才改变，所以我们可以通过contenthash解决上诉问题。")]),h._v(" "),a("p",[h._v("一般来说 我们可以将JS文件使用 chunkhash，CSS文件使用 contenthash。")])])}),[],!1,null,null,null);t.default=n.exports}}]);