(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{591:function(a,e,t){"use strict";t.r(e);var s=t(42),n=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"webpack-优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-优化"}},[a._v("#")]),a._v(" webpack 优化")]),a._v(" "),t("h3",{attrs:{id:"一-缩小文件的搜索范围"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-缩小文件的搜索范围"}},[a._v("#")]),a._v(" 一.缩小文件的搜索范围")]),a._v(" "),t("h4",{attrs:{id:"_1-resolve字段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-resolve字段"}},[a._v("#")]),a._v(" 1.resolve字段")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("设置 resole.modules 避免层层查找。")]),a._v(" "),t("p",[a._v("例如："),t("code",[a._v("[path.resolve(__dirname, 'node_modules')]")])])]),a._v(" "),t("li",[t("p",[a._v("设置 resolve.alias 直接使用库的min文件")]),a._v(" "),t("p",[a._v("例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  \n  resolve.alias: {\n    'react': [path.resolve(__dirname, './node_modules/react/dist/react.min.js')],\n    '@Component': '../component'\n  }\n  \n")])])]),t("p",[a._v("像第二种，当我们的文件结构很复杂的时候，我们可以使用 import {} from '@Component/...' 来引用我们的组件。")])]),a._v(" "),t("li",[t("p",[a._v("配置 resolve.extensions 减少文件查找")]),a._v(" "),t("p",[a._v("例如："),t("code",[a._v("resolve.extensions: ['.js', '.min.js']")])])]),a._v(" "),t("li",[t("p",[a._v("配置 module.noParse 字段告诉Webpack不必解析那些文件，可以用来排除非模块化库文件的解析。")])]),a._v(" "),t("li",[t("p",[a._v("使用loader的时候，可以配置exclude、include缩小搜索范围。")])])]),a._v(" "),t("h3",{attrs:{id:"二、合理利用缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、合理利用缓存"}},[a._v("#")]),a._v(" 二、合理利用缓存")]),a._v(" "),t("p",[a._v("大部分loader都提供了cache的配置项，比如 babel-loader，我们可以设置 babel-loader?cacheDirectory=true 来开启缓存。也可以用过一个神奇的 cache-loader 将loader的编译结果写入硬盘缓存。这里主要，要写在第一位哦。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: ['cache-loader', ...loaders],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n\n")])])]),t("p",[a._v("另外压缩阶段也是可以设置缓存的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        cache: true,\n        parallel: true,\n      }),\n    ],\n  },\n};\n\n")])])]),t("h3",{attrs:{id:"三、多进程转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、多进程转换"}},[a._v("#")]),a._v(" 三、多进程转换")]),a._v(" "),t("h4",{attrs:{id:"happypack-不建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happypack-不建议"}},[a._v("#")]),a._v(" Happypack ( 不建议 )")]),a._v(" "),t("p",[a._v("运行在node上的webpack也不会避免单线程的诅咒，只能一个文件一个文件的进行处理，不能并行处理。不过webpack提供的Happypack可以有效的帮助我们解决这个问题。Happypack可以将任务分解给多个子线程，最终发给主线程。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\nconst HappyPack = require('happypack');\nconst os = require('os');\nconst happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\n\nmodule.export = {\n...\n\n  plugins: [\n    new HappyPack({\n      id: 'babel',\n      loaders: [{\n        loader: 'babel-loader',\n        options: {\n          presets: ['@babel/preset-env', '@babel/preset-react']\n        }\n      }],\n      threadPool: happyThreadPool\n    }),\n    new HappyPack({\n      id: 'css',\n      loaders: ['style-loader', 'css-loader'],\n      threadPool: happyThreadPool\n    }),\n  ],\n  module: {\n      rules: [\n          {\n              test: /\\.js$/,\n              use: ['happypack/loader?id=babel'],\n              exclude: path.resolve(__dirname, 'node_modules')\n          },\n          {\n              test: /\\.css$/,\n              use: ['happypack/loader?id=css']\n          }\n      ]\n  }\n}\n\n")])])]),t("h4",{attrs:{id:"thread-loader-建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#thread-loader-建议"}},[a._v("#")]),a._v(" thread-loader ( 建议 )")]),a._v(" "),t("p",[a._v("把这个 loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[a._v("\nuse"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    loader"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"thread-loader"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 有同样配置的 loader 会共享一个 worker 池(worker pool)")]),a._v("\n    options"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 产生的 worker 的数量，默认是 cpu 的核心数")]),a._v("\n      workers"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 一个 worker 进程中并行执行工作的数量")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 默认为 20")]),a._v("\n      workerParallelJobs"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("50")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 额外的 node.js 参数")]),a._v("\n      workerNodeArgs"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'--max-old-space-size'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'1024'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 闲置时定时删除 worker 进程")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 默认为 500ms")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在")]),a._v("\n      poolTimeout"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2000")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 池(pool)分配给 worker 的工作数量")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 默认为 200")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 降低这个数值会降低总体的效率，但是会提升工作分布更均一")]),a._v("\n      poolParallelJobs"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("50")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 池(pool)的名称")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 可以修改名称来创建其余选项都一样的池(pool)")]),a._v("\n      name"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"my-pool"')]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"expensive-loader"')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),t("h3",{attrs:{id:"四、文件压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、文件压缩"}},[a._v("#")]),a._v(" 四、文件压缩")]),a._v(" "),t("h4",{attrs:{id:"_1-webpack自带压缩方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack自带压缩方式"}},[a._v("#")]),a._v(" 1.webpack自带压缩方式")]),a._v(" "),t("p",[t("code",[a._v("new UglifyJsPlugin()")]),a._v(", 具体参数，移步官网 "),t("a",{attrs:{href:"https://www.webpackjs.com/plugins/uglifyjs-webpack-plugin/",target:"_blank",rel:"noopener noreferrer"}},[a._v("地址"),t("OutboundLink")],1)]),a._v(" "),t("h4",{attrs:{id:"_2-多进程压缩文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-多进程压缩文件"}},[a._v("#")]),a._v(" 2.多进程压缩文件")]),a._v(" "),t("p",[a._v("传统压缩方式是一个文件一个文件的进行压缩，我们可以使用 ParallelUglifyPlugin 开启多进程压缩。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\nconst ParallelUglifyPlugin = require('wbepack-parallel-uglify-plugin');\n//...\nplugins: [\n    new ParallelUglifyPlugin({\n        uglifyJS:{\n            //...这里放uglifyJS的参数\n        },\n        //...其他ParallelUglifyPlugin的参数，设置cacheDir可以开启缓存，加快构建速度\n    })\n]\n\n")])])]),t("h3",{attrs:{id:"五、抽离公共资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、抽离公共资源"}},[a._v("#")]),a._v(" 五、抽离公共资源")]),a._v(" "),t("h4",{attrs:{id:"_1-webpack-dll-plugin-不推荐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack-dll-plugin-不推荐"}},[a._v("#")]),a._v(" 1.webpack-dll-plugin（不推荐）")]),a._v(" "),t("p",[a._v("不推荐原因1： 每次依赖更新需要手动维护\n不推荐原因2： 将所有资源预编译成一份文件，导致单个文件的体积过大，符合http1.1的标准，可以减少请求数，但是对于http2来说，不容易体现多路复用的优势。")]),a._v(" "),t("h4",{attrs:{id:"_2-externals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-externals"}},[a._v("#")]),a._v(" 2.externals")]),a._v(" "),t("p",[a._v("它的原理其实就是不将我们指定的资源进行打包，而是用过CDN的方式进行引入，减小包的体积，提高构建速度。不过要记得在HTML文件里引入cdn哦。最好使用公司自己的cdn服务，都是泪啊。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('\nmodule.exports = {\n  ...,\n  externals: {\n    "react": "React",\n    "react-dom": "ReactDOM",\n    "redux": "Redux",\n    "react-router-dom": "ReactRouterDOM"\n  }\n}\n\n')])])]),t("h3",{attrs:{id:"六、按需加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、按需加载"}},[a._v("#")]),a._v(" 六、按需加载")]),a._v(" "),t("p",[a._v("webpack 4 最大的改动就是废除了 CommonsChunkPlugin 引入了 optimization.splitChunks。")]),a._v(" "),t("p",[a._v("可以分为五类")]),a._v(" "),t("ul",[t("li",[a._v("基础类库 比如 react、react-dom等")]),a._v(" "),t("li",[a._v("UI库 antd等")]),a._v(" "),t("li",[a._v("低频组件 echarts等")]),a._v(" "),t("li",[a._v("公共组件 项目中公共组件")]),a._v(" "),t("li",[a._v("业务代码")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\noptimization: {\n  splitChunks: {\n    chunks: 'all',\n    cacheGroups: {\n      libs: {\n        name: 'chunks-lib',\n        test: /[\\\\/]node_modules[\\\\/]/,\n        priority: 10,\n        chunks: 'initial'\n      },\n      antd: {\n        name: 'antd-lib',\n        test: /[\\\\/]node_modules[\\\\/]antd[\\\\/]/,\n        priority: 20,\n        chunks: 'initial'\n      },\n      antdDesign: {\n        name: 'antd-lib',\n        test: /[\\\\/]node_modules[\\\\/]@ant-design[\\\\/]/,\n        priority: 20,\n        chunks: 'initial'\n      },\n      echarts: {\n        name: 'echarts',\n        test: /[\\\\/]node_modules[\\\\/]echarts[\\\\/]/,\n        priority: 20,\n        chunks: 'initial'\n      }\n    }\n  }\n}\n\n\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);